<!DOCTYPE html>
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

<link href="css/shCore.css" rel="stylesheet" type="text/css">
<link href="css/shThemeDefault.css" rel="stylesheet" type="text/css">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Documentation | ESBMC</title>
<meta name="generator" content="Jekyll v3.7.3">
<meta property="og:title" content="ESBMC: An Industrial-Strength C Model Checker">
<meta property="og:locale" content="en_US">
<meta name="description" content="SMT-based Context-Bounded Model Checker for C Programs.">
<meta property="og:description" content="SMT-based Context-Bounded Model Checker for C Programs.">
<link rel="canonical" href="https://ssvlab.github.io/">
<meta property="og:url" content="https://ssvlab.github.io/">
<meta property="og:site_name" content="ESBMC">
<script type="application/ld+json">
{"name":"ESBMC","description":"SMT-based Context-Bounded Model Checker for C Programs..","@type":"WebSite","url":"https://ssvlab.github.io/","headline":"News","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="./files/style.css">
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="https://ssvlab.github.io/esbmc/index.html">ESBMC</a></h1>
        <p>An Efficient SMT-based Bounded Model Checker.</p>
        <p class="view"><a class="hl" href="https://github.com/esbmc/esbmc" target="_blank"><b>GitHub</b></a></p>
        <p class="view">
          <a href="https://ssvlab.github.io/esbmc/documentation.html"><b>Documentation</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/news.html"><b>News</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/publications.html"><b>Publications</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/sv-comp.html"><b>SV-COMP</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/test-comp.html"><b>Test-Comp</b></a><br>
	  <a href="https://ssvlab.github.io/esbmc/people.html"><b>People</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/applications.html"><b>Applications</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/archive.html"><b>Download Archive</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/contrib.html"><b>Third Party Contributions</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/benchmarks/"><b>Index of /benchmarks</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/acknowledgments.html"><b>Acknowledgments</b></a><br>
        </p>
      </header>
      <section>

      <h2 id="documentation">Documentation</h2>

	  <a href="#how-to-install">Installing ESBMC</a>
	  <br>
      <a href="#show-features">ESBMC Features</a>
	  <br>
	  <a href="#how-to-run">Illustrative Examples</a>
	  <br>
      <a href="#witness">Witness Generation</a>
	  <br>
      <a href="#unwinding-assertions">Unwinding Assertions</a>
      <br>
      <a href="#modelling-nondeterminism">Modeling with non-determinism</a>
      <br>
      <a href="#falsification">Falsification</a>
      <br>
      <a href="#incremental-bmc">Incremental BMC</a>
      <br>
      <a href="#k-induction">k-Induction proof rule</a>
      <br>
      <a href="#multiple-files">Verification of modules that rely on larger structures</a>
      <br>
      <a href="#esbmc-python">Verification of Python programs</a>
      <br>
      <a href="#esbmc-solidity">Verification of Solidity Smart Contracts</a>
      <br>
      <a
      href="#multiple-property-verification">Multiple Property Verification</a>
      <br>
    <a href="#code-coverage-metric">Code Coverage Metric</a>
    <br>
      <a href="#smt-backends">Supported SMT backends</a><br>
	  <a href="#esbmc-support">ESBMC Support</a>
	  <br>
          <br>

          <p>A demonstration is available <a href="https://www.youtube.com/watch?v=YcJjXHlN1v8" target="_blank">here</a>.</p>

          <!-- <p>You can also use ESBMC via our <a href="http://18.225.0.33/esbmc.php"> web interface</a>. -->

	<p>A set of slides about the detection of software vulnerabilities using ESBMC: <a href="https://ssvlab.github.io/lucasccordeiro/courses/2022/01/software-security/slides/lecture03.pdf"> Part I</a>, <a href="https://ssvlab.github.io/lucasccordeiro/courses/2022/01/software-security/slides/lecture04.pdf"> Part II</a>, and <a href="https://ssvlab.github.io/lucasccordeiro/courses/2022/01/software-security/slides/lecture05.pdf"> Part III</a>.

          <p>This <a href="https://ssvlab.github.io/lucasccordeiro/courses/2022/01/software-security/index.html">software security</a> course describes further implementation details about ESBMC.</p>
          <h3 id="how-to-install">Installing ESBMC</h3>

	  <p>To install ESBMC on your machine, you should download the latest binary for Linux and Windows OSs from <a href="https://github.com/esbmc/esbmc/releases">GitHub</a> and save and unzip it on your disk.</p>

          <p>Once the user unzips the release, they should read the license before running ESBMC. The ESBMC distribution is split into two directories:</p>

          <ul>
              <li><code>bin</code>: contains a static-binary file of ESBMC;</li>
              <li><code>license</code>: contains the ESBMC, Z3 and Boolector licenses.</li>
          </ul>

	  <p>If the user wants to use other SMT solvers (e.g., MathSAT, Yices, CVC4), we recommend checking out the ESBMC source code, which is hosted on <a href="https://github.com/esbmc/esbmc" target="_blank">GitHub</a>, and then follow the instructions in the <a href="https://github.com/esbmc/esbmc/blob/master/BUILDING.md" target="_blank">BUILDING </a>file.</p>

          <h3 id="show-features">ESBMC Features</h3>

          <p>ESBMC aims to support all of C11, and detects errors in software by simulating a finite prefix of the program execution with all possible inputs. Classes of problems that can be detected include:</p>

          <ul>
              <li>User specified assertion failures;</li>
              <li>Out of bounds array access;</li>
              <li>Illegal pointer dereferences, such as:
              <ul>
                <li>Dereferencing null;</li>
                <li>Performing an out-of-bounds dereference;</li>
                <li>Double-free of malloc'd memory;</li>
                <li>Misaligned memory access;</li>
              </ul></li>
              <li>Integer overflows;</li>
              <li>NaN (Floating-point);</li>
              <li>Divide by zero;</li>
              <li>Memory leak.</li>
          </ul>

          <p>Concurrent software (using the pthread API) is verified by explicitly exploring interleavings, thus producing one symbolic execution per interleaving. By default, pointer-safety, array-out-of-bounds, division-by-zero, and user-specified assertions  will be checked for; one can also specify options to check multi-threaded programs for:</p>

          <ul>
            <li>Deadlock (only on pthread mutexes and conditional variables);</li>
            <li>Data races (<i>i.e.</i>, competing writes);</li>
            <li>Atomicity violations at visible assignments;</li>
            <li>Lock acquisition ordering.</li>
          </ul>

          <p>By default, ESBMC performs a "lazy" depth-first search of interleavings but can also encode (explicitly) all interleavings into a single SMT formula. Currently, many SMT solvers are supported:</p>

          <ul>
            <li>Z3 4.9+;</li>
            <li>Boolector 3.2+;</li>
            <li>MathSAT 5.6+;</li>
            <li>CVC4 1.8;</li>
            <li>Yices 2.6+;</li>
            <li>Bitwuzla 0.3+;</li>
          </ul>

          <p>In addition, ESBMC can be configured to use the SMTLIB interactive text format to write the formula to a file or interactively with a pipe to communicate with an arbitrary solver process, although insignificant overheads are involved.
          See the section on <a href="#smt-backends">supported SMT backends</a> for details.</p>

	  <p>ESBMC uses clang as its front-end, which brings several advantages:</p>

          <ul>
            <li>We address the problem of maintaining a frontend for C and C++ simply and elegantly: by using clangs API to access and traverse the program AST, without having details of the input program compiled away.</li>
	    <li>ESBMC provides compilation error messages as expected from a compiler.</li>
	    <li>ESBMC leverages clang’s powerful static analyzer to provide meaningful warnings when parsing the program.</li>
	    <li>Clang can simplify some expressions, e.g., calculate <i>sizeof/alignof</i> expressions, evaluate static asserts, evaluate if a dynamic cast is always null, etc., which eases the analysis of the input program.</li>
          </ul>
          <p>A limited subset of C++98 is supported too -- a library modeling the STL is also available.</p>

          <p>To check all available options of the ESBMC tool, type:</p>

          <pre style="color: silver; background: black;">$esbmc --help</pre>

	  	  <h3 id="how-to-run">Illustrative Examples</h3>

          <p>As an illustrative example to show some of the ESBMC features concerning floating-point numbers, consider the following C code:  </p>

<pre class='brush: c'>
#include &lt;math.h&gt;
int main() {
  unsigned int N = nondet_uint();
  double x = nondet_double();
  if(x &lt;= 0 || isnan(x))
    return 0;
  unsigned int i = 0;
  while(i &lt; N) {
    x = (2*x);
    assert(x>0);
    ++i;
  }
  assert(x>0);
  return 0;
}
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>

          <p>Here, ESBMC is invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --floatbv --k-induction</pre>

	  <p> where <i>file.c</i> is the C program to be checked, <i>--floatbv</i> indicates that ESBMC will use floating-point arithmetic to represent the program's <i>float</i> and <i>double</i> variables, and <i>--k-induction</i> selects the <i>k</i>-induction proof rule. The user can select the SMT solver, property, and verification strategy. For this particular C program, ESBMC provides the following output as the verification result:</p>

<pre style="color: silver; background: black;">
*** Checking inductive step
Starting Bounded Model Checking
Unwinding loop 2 iteration 1 file ex5.c line 8 function main
Not unwinding loop 2 iteration 2 file ex5.c line 8 function main
Symex completed in: 0.001s (40 assignments)
Slicing time: 0.000s (removed 16 assignments)
Generated 2 VCC(s), 2 remaining after simplification (24 assignments)
No solver specified; defaulting to Boolector
Encoding remaining VCC(s) using bit-vector/floating-point arithmetic
Encoding to solver time: 0.005s
Solving with solver Boolector 3.2.0
Encoding to solver time: 0.005s
Runtime decision procedure: 0.427s
BMC program time: 0.435s

VERIFICATION SUCCESSFUL

Solution found by the inductive step (k = 2)
</pre>

<p>As an illustrative example to show some of the ESBMC features concerning pointer safety, consider the following C code:  </p>

          <pre class='brush: c'>
#include &lt;stdlib.h&gt;
int *a, *b;
int n;
#define BLOCK_SIZE 128
void foo () {
  int i;
  for (i = 0; i &lt; n; i++)
    a[i] = -1;
  for (i = 0; i &lt; BLOCK_SIZE - 1; i++)
    b[i] = -1;
}
int main () {
  n = BLOCK_SIZE;
  a = malloc (n * sizeof(*a));
  b = malloc (n * sizeof(*b));
  *b++ = 0;
  foo ();
  if (b[-1])
  { free(a); free(b); }
  else
  { free(a); free(b); }
  return 0;
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

          <p>Here, ESBMC is invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --memory-leak-check</pre>

	  <p> where <i>file.c</i> is the C program to be checked and <i>--memory-leak-check</i> indicates that ESBMC will check for memory leaks. For this particular C program, ESBMC produces the following counterexample:</p>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file ex2.c line 14 function main thread 0
----------------------------------------------------
  a = (signed int *)(&dynamic_1_array[0])

State 2 file ex2.c line 15 function main thread 0
----------------------------------------------------
  b = (signed int *)0

State 3 file ex2.c line 16 function main thread 0
----------------------------------------------------
  b = 0 + 1

State 6 file ex2.c line 16 function main thread 0
----------------------------------------------------
Violated property:
  file ex2.c line 16 function main
  dereference failure: NULL pointer
</pre>

<p>In the counterexample shown above, State 1 indicates that memory has been allocated, which is identified by 'dynamic_1_array'. State 2 indicates that the call to the <i>malloc</i> function did not succeed, and thus returned NULL, i.e., the memory was not allocated. Note that ESBMC allows the user not to check for malloc/new failure via <i>--force-malloc-success</i>. State 3 represents an assignment to pointer b. Lastly, State 6 reports a failure to dereference pointer b.</p>

          <p>As an illustrative example to show some of the ESBMC features concerning concurrency, consider the following C code:  </p>

<pre class='brush: c'>
#include &lt;pthread.h&gt;
int n=0; //shared variable
pthread_mutex_t mutex;
void* P(void* arg) {
  int tmp, i=1;
  while (i&lt;=10) {
    pthread_mutex_lock(&mutex);
    tmp = n;
    n = tmp + 1;
    pthread_mutex_unlock(&mutex);
    i++;
  }
  return NULL;
}
int main (void) {
  pthread_t id1, id2;
  pthread_mutex_init(&mutex, NULL);
  pthread_create(&id1, NULL, P, NULL);
  pthread_create(&id2, NULL, P, NULL);
  pthread_join(id1, NULL);
  pthread_join(id2, NULL);
  assert(n == 20);
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

  <p>Here, we create two threads <i>id1</i> and <i>id1</i>; both threads will run the same code as implemented in <b>P</b>. Note that these two threads communicate via the shared memory <i>n</i>, which is protected by a mutex via <b>pthread_mutex_lock</b> and <b>pthread_mutex_unlock</b>. Note further that the thread <i>main</i> contains two joining points via <b>pthread_join</b> for <i>id1</i> and <i>id2</i>.</p>

            <p>ESBMC can be invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --context-bound 2</pre>

          <p> where <i>file.c</i> is the C program to be checked and <i>--context-bound nr</i> limits number of context switches for each thread. For this particular C program, ESBMC produces the following verification result:</p>

<pre style="color: silver; background: black;">
*** Thread interleavings 612 ***
Unwinding loop 1 iteration 10 file test3.c line 6 function P
Unwinding loop 1 iteration 1 file test3.c line 6 function P
Unwinding loop 1 iteration 2 file test3.c line 6 function P
Unwinding loop 1 iteration 3 file test3.c line 6 function P
Unwinding loop 1 iteration 4 file test3.c line 6 function P
Unwinding loop 1 iteration 5 file test3.c line 6 function P
Unwinding loop 1 iteration 6 file test3.c line 6 function P
Unwinding loop 1 iteration 7 file test3.c line 6 function P
Unwinding loop 1 iteration 8 file test3.c line 6 function P
Unwinding loop 1 iteration 9 file test3.c line 6 function P
Unwinding loop 1 iteration 10 file test3.c line 6 function P
Symex completed in: 0.031s (431 assignments)
Slicing time: 0.001s (removed 183 assignments)
Generated 149 VCC(s), 7 remaining after simplification (248 assignments)
No solver specified; defaulting to Boolector
Encoding remaining VCC(s) using bit-vector/floating-point arithmetic
Encoding to solver time: 0.004s
Solving with solver Boolector 3.2.0
Encoding to solver time: 0.004s
Runtime decision procedure: 0.001s
BMC program time: 0.040s

VERIFICATION SUCCESSFUL
</pre>

          <h3 id="witness">Witness Generation</h3>

          <p>When ESBMC refutes a property, it produces a counterexample that can be used to debug the program to find the root cause of the problem. For this purpose, ESBMC can produce the counterexample in graphml format to make its evaluation easier (e.g., by building a tool that allows graphical visualization). </p>

          <p>As an illustrative example, consider the following fragment of C code, where we declare two bit-vectors of size 10 each: x and y, and then check whether x == y. </p>

<pre class='brush: c'>
#include &lt;assert.h&gt;

int main() {
  _ExtInt(10) x = nondet_float();
  _ExtInt(10) y = nondet_int();
  assert(x == y);
  return 0;
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

          <p>If we call ESBMC as <i>esbmc main.c --witness-output main.graphml</i>, where <i>main.c</i> is the C program we want to verify while <i>main.graphml</i> stores the counterexample in graphml format, then ESBMC will produce the following output:</p>

<pre style="color: silver; background: black;">
&lt;xmp>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  &lt;key id="frontier" attr.name="isFrontierNode" attr.type="boolean" for="node">
    &lt;default>false&lt;/default>
  &lt;/key>
  &lt;key id="violation" attr.name="isViolationNode" attr.type="boolean" for="node">
    &lt;default>false&lt;/default>
  &lt;/key>
  &lt;key id="entry" attr.name="isEntryNode" attr.type="boolean" for="node">
    &lt;default>false&lt;/default>
  &lt;/key>
  &lt;key id="sink" attr.name="isSinkNode" attr.type="boolean" for="node">
    &lt;default>false&lt;/default>
  &lt;/key>
  &lt;key id="cyclehead" attr.name="cyclehead" attr.type="boolean" for="node">
    &lt;default>false&lt;/default>
  &lt;/key>
  &lt;key id="sourcecodelang" attr.name="sourcecodeLanguage" attr.type="string" for="graph"/>
  &lt;key id="programfile" attr.name="programfile" attr.type="string" for="graph"/>
  &lt;key id="programhash" attr.name="programhash" attr.type="string" for="graph"/>
  &lt;key id="creationtime" attr.name="creationtime" attr.type="string" for="graph"/>
  &lt;key id="specification" attr.name="specification" attr.type="string" for="graph"/>
  &lt;key id="architecture" attr.name="architecture" attr.type="string" for="graph"/>
  &lt;key id="producer" attr.name="producer" attr.type="string" for="graph"/>
  &lt;key id="sourcecode" attr.name="sourcecode" attr.type="string" for="edge"/>
  &lt;key id="startline" attr.name="startline" attr.type="int" for="edge"/>
  &lt;key id="startoffset" attr.name="startoffset" attr.type="int" for="edge"/>
  &lt;key id="control" attr.name="control" attr.type="string" for="edge"/>
  &lt;key id="invariant" attr.name="invariant" attr.type="string" for="node"/>
  &lt;key id="invariant.scope" attr.name="invariant.scope" attr.type="string" for="node"/>
  &lt;key id="assumption" attr.name="assumption" attr.type="string" for="edge"/>
  &lt;key id="assumption.scope" attr.name="assumption" attr.type="string" for="edge"/>
  &lt;key id="assumption.resultfunction" attr.name="assumption.resultfunction" attr.type="string" for="edge"/>
  &lt;key id="enterFunction" attr.name="enterFunction" attr.type="string" for="edge"/>
  &lt;key id="returnFromFunction" attr.name="returnFromFunction" attr.type="string" for="edge"/>
  &lt;key id="endline" attr.name="endline" attr.type="int" for="edge"/>
  &lt;key id="endoffset" attr.name="endoffset" attr.type="int" for="edge"/>
  &lt;key id="threadId" attr.name="threadId" attr.type="string" for="edge"/>
  &lt;key id="createThread" attr.name="createThread" attr.type="string" for="edge"/>
  &lt;key id="witness-type" attr.name="witness-type" attr.type="string" for="graph"/>
  &lt;graph edgedefault="directed">
    &lt;data key="producer">ESBMC 6.7.0&lt;/data>
    &lt;data key="sourcecodelang">C&lt;/data>
    &lt;data key="architecture">64bit&lt;/data>
    &lt;data key="programfile">main.c&lt;/data>
    &lt;data key="programhash">7ba149c407ef7ae9e971bbc937b37a624575d6a5&lt;/data>
    &lt;data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )&lt;/data>
    &lt;data key="creationtime">2021-06-07T13:37:38&lt;/data>
    &lt;data key="witness-type">violation_witness&lt;/data>
    &lt;node id="N0">
      &lt;data key="entry">true&lt;/data>
    &lt;/node>
    &lt;node id="N1"/>
    &lt;edge id="E0" source="N0" target="N1">
      &lt;data key="enterFunction">main&lt;/data>
      &lt;data key="createThread">0&lt;/data>
    &lt;/edge>
    &lt;node id="N2"/>
    &lt;edge id="E1" source="N1" target="N2">
      &lt;data key="startline">4&lt;/data>
      &lt;data key="assumption">x = -512;&lt;/data>
      &lt;data key="threadId">0&lt;/data>
    &lt;/edge>
    &lt;node id="N3"/>
    &lt;edge id="E2" source="N2" target="N3">
      &lt;data key="startline">5&lt;/data>
      &lt;data key="assumption">y = -166;&lt;/data>
      &lt;data key="threadId">0&lt;/data>
    &lt;/edge>
    &lt;node id="N4">
      &lt;data key="violation">true&lt;/data>
    &lt;/node>
    &lt;edge id="E3" source="N3" target="N4">
      &lt;data key="startline">93&lt;/data>
      &lt;data key="threadId">0&lt;/data>
    &lt;/edge>
  &lt;/graph>
&lt;/graphml>
&lt;/xmp>

</pre>
         <p>We recommend reading <a href="https://github.com/sosy-lab/sv-witnesses">Exchange Format for Violation Witnesses and Correctness Witnesses</a> to obtain further information about violation and correctness witnesses in graphml format.</p>


          <h3 id="unwinding-assertions">Unwinding Assertions</h3>

          <p>In ESBMC, all loops are "unwound", i.e., replaced by several guarded copies of the loop body; the same happens for backward "gotos" and recursive functions. Soundness requires that ESBMC insert a so-called <i>unwinding assertion</i> at the end of the loop. As an example, consider the simple C code fragment illustrated below:</p>

<pre class='brush: c'>
1 unsigned int x=∗;
2 while ( x>0) x−−;
3 assert ( x==0);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

<p> Note that the loop in line 2 runs an unknown number of times, depending on the initial non-deterministic value assigned to x in line 1. The assertion in line 3 holds independent of x's initial value. BMC tools typically fail to verify programs that contain such loops. In particular, BMC tools introduce an unwinding assertion at the end of the loop, as illustrated in line 5 of this C code fragment.

<pre class='brush: c'>
1 unsigned int x=∗;
2 if(x>0)
3   x−−;   // k copies
4   ...
5 assert (!(x>0));
6 assert(x==0);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

<p>This unwinding assertion in line 5 causes the BMC tool to fail if <i>k</i> is too small as follows:</p>

<pre class='brush: c'>
1 #include &lt;assert.h&gt;
2 unsigned int nondet_uint();
3 int main() {
4   unsigned int x=nondet_uint();
5   while(x>0) x--;
6   assert(x==0);
7   return 0;
8 }
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

<pre style="color: silver; background: black;">$esbmc file.c --unwind 3</pre>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file file.c line 4 function main thread 0
----------------------------------------------------
  x = 3170305 (00000000 00110000 01100000 00000001)

State 2 file file.c line 5 function main thread 0
----------------------------------------------------
  x = 3170304 (00000000 00110000 01100000 00000000)

State 3 file file.c line 5 function main thread 0
----------------------------------------------------
  x = 3170303 (00000000 00110000 01011111 11111111)

State 4 file file.c line 5 function main thread 0
----------------------------------------------------
Violated property:
  file file.c line 5 function main
  unwinding assertion loop
</pre>

          <h3 id="modelling-nondeterminism">Modeling with non-determinism</h3>

	  <p>ESBMC extends C with three modeling features:</p>

	  <p> __ESBMC_assert(e): aborts execution when <i>e</i> is false. </p>
<pre class='brush: c'>
void __ESBMC_assert (e, "some message here");
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>

          <p> nondet_X(): returns non-deterministic X-value, with X in {bool, char, int, float, double, loff_t, long, pchar, pthread_t, sector_t, short, size_t, u32, uchar, uint, ulong, unsigned, ushort} (no side effects, pointer for void *, etc.). ESBMC assumes that the functions are implemented according to the following template:</p>
<pre class='brush: c'>
X nondet_X () { X val; return val; }
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>

          <p> __ESBMC_assume(e): "ignores" execution when <i>e</i> is false, no-op otherwise. </p>
<pre class='brush: c'>
void __ESBMC_assume(e);
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>

          <p> __ESBMC_atomic_begin(), __ESBMC_atomic_end(): For modeling an atomic execution of a sequence of statements in a multi-threaded run-time environment, those statements can be placed between two function calls. </p>
<pre class='brush: c'>
__ESBMC_atomic_begin();
//shared memory
__ESBMC_atomic_end();
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
	
<p> __ESBMC_init_object(): Initialize a memory object. This can be used to mark any pointer or symbol as non-determnistic.</p>
<pre class='brush: c'>
my_complex_type T = {0,0,0};
__ESBMC_init_object(T);
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>


<p>As an illustrative example to show some of the ESBMC features to model non-determinism, consider the following C code:  </p>

<pre class='brush: c'>
1 int main() {
2   int x=nondet_int(),y=nondet_int(),z=nondet_int();
3   __ESBMC_assume(x > 0 && y > 0 && z > 0);
4   __ESBMC_assume(x &lt; 16384 && y &lt; 16384 && z &lt; 16384);
5   assert(x*x + y*y != z*z);
6   return 0;
7 }
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

<p>Here, ESBMC is invoked as follows:</p>

<pre style="color: silver; background: black;">$esbmc file.c</pre>

<p>For this particular C program, ESBMC produces the following counterexample:</p>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file file.c line 2 function main thread 0
----------------------------------------------------
  x = 252 (00000000 00000000 00000000 11111100)

State 2 file file.c line 2 function main thread 0
----------------------------------------------------
  y = 561 (00000000 00000000 00000010 00110001)

State 3 file file.c line 2 function main thread 0
----------------------------------------------------
  z = 615 (00000000 00000000 00000010 01100111)

State 6 file file.c line 5 function main thread 0
----------------------------------------------------
Violated property:
  file file.c line 5 function main
  assertion
  (_Bool)(x * x + y * y != z * z)

VERIFICATION FAILED
</pre>

          <h3 id="falsification">Falsification</h3>

	  <pre style="color: silver; background: black;">$esbmc file.c --falsification</pre>

	  <p>Our falsification approach (<i>--falsification</i>) uses an iterative technique and verifies the program for each unwind bound up to either a maximum default value of <i>50</i> (which can be changed via --max-k-step nr), or indefinitely (until it exhausts the time or memory limits). Intuitively, we aim to find a counterexample with up to <i>k</i> loop unwindings. The algorithm relies on the symbolic execution engine to increasingly unwind the loop after each iteration.</p>

          <p>This approach replaces all unwinding assertions (e.g., assertions to check if a loop was completely unrolled) with unwinding assumptions. Normally, this would lead to unsound behaviour but, since the falsification algorithm cannot provide correctness validation, it will not affect the search for bugs. This approach is focused on bug finding and does not care if a loop was not completely unrolled; it only cares if the current number of unwindings will lead to a property violation.</p>

	  <p>The falsification algorithm also offers the option to change the granularity of the increment; the default value is <i>1</i>, but can be increased in order to meet any expected behaviour via --k-step nr. Note that changing the value of the increment can lead to slower verification time and might not present the shortest counterexample possible for a property violation.</p>

	  <h3 id="incremental-bmc">Incremental BMC</h3>

	  <pre style="color: silver; background: black;">$esbmc file.c --incremental-bmc</pre>

	  <p>Our incremental BMC approach (<i>--incremental-bmc</i>) uses an iterative technique and verifies the program for each unwind bound up to either a maximum default value of <i>50</i>, which can be modified via --max-k-step nr, or indefinitely (until it exhausts the time or memory limits). Intuitively, we aim to either find a counterexample with up to <i>k</i> loop unwinding or to fully unwind all loops so we can provide a correct result. The algorithm relies on the symbolic execution engine to increasingly unwind the loop after each iteration of the algorithm.</p>

          <p>The approach is divided in two steps: one that tries to find property violations and one that checks if all the loops were fully unwound. When searching for property violation, the tool replaces all unwinding assertions (e.g., assertions to check if a loop was completely unrolled) with unwinding
assumptions. Normally, this would lead to unsound behaviour, however, the first step can only find property violations and reporting an unwinding assertion failure is not a real bug. The next step is to check if all loops in the program were fully unrolled. This is done by checking if all the unwinding assertions are unsatisfiable; note that checking any other assertion in the program, for the current <i>k</i>, is not necessary as they were already verified. </p>

          <p>The algorithm also offers the option to change the granularity of the increment; the default value is <i>1</i>, but can be increased in order to meet any expected behaviour via --k-step nr. Note that changing the value of the increment can lead to slower verification time and might not present the shortest counterexample possible for the property violation.</p>

	  <h3 id="k-induction">k-Induction proof rule</h3>

	  <pre style="color: silver; background: black;">$esbmc file.c --k-induction</pre>

	  <p>The original <i>k</i>-induction algorithm (<i>--k-induction</i>) presented by Sheeran et al. [1] was used to prove safety properties in hardware verification. The algorithm was later refined by Alastair et al. [2] and applied to the verification of general C programs. Our algorithm is a combination of both approaches. It can be summarized as follows:</p>

	  \begin{equation}
  \begin{array}{rcrrl}
           & \neg & B(k) & \rightarrow & \text{program contains bug}  \\
    B(k) & \wedge & F(k) & \rightarrow & \text{program is correct}  \\
    B(k) & \wedge & I(k) & \rightarrow & \text{program is correct}
  \end{array}
\end{equation}

           <p> Here <i>B(k)</i> is the base case, <i>F(k)</i> is the forward condition and <i>I(k)</i> is the inductive step; <i>k</i> is the number of loop unwinding used for each step. For the base case we use the plain BMC technique, hence we can only find property violations here. If the base case error check is satisfiable, then the algorithm presents a counterexample of length <i>k</i>. For the forward condition and inductive step, the base case must be checked for satisfiability before the result is presented. This is a soundness requirement of the technique.</p>

	   <p>The forward condition attempts to prove that all loops in the program were fully unrolled; this is achieved by adding <i>unwinding assertions</i> after all loops. The forward condition is further optimized to only check the <i>unwinding assertions</i>, as all program assertions are already proven to be unsatisfiable by the base case, for the current value of <i>k</i>. The inductive step attempts to prove that, if the property is valid for <i>k</i> iterations, then it must be valid for the next iteration; this is achieved by assigning nondeterministic values to all variable written inside a loop body,
assuming <i>k-1</i> invariants and checking if the invariant holds at the <i>k</i>th iteration. </p>

	   <p> The algorithm starts with <i>k = 1</i> and increases it up to a maximum
number of iterations, incrementally analysing the program, until it either finds a bug (i.e., the base case is satisfiable for some <i>k</i>), proves correctness (i.e., the base case is unsatisfiable and either the forward condition or inductive step is unsatisfiable for some <i>k</i>), or exhausts either time or memory constraints.</p>

	   <p>We can also use two additional options together with the k-induction proof rule to produce (inductive) invariants:</p>

	   <ol>
       <li><i>--interval-analysis</i>: enable interval analysis for integer variables and add assumes to the program.</li>
       <li><i>--add-symex-value-sets</i>: enable value set analysis for pointers and add assumes to the program.</li>
       </ol>

	   <p>[1] Mary Sheeran, Satnam Singh, Gunnar Stålmarck: Checking Safety Properties Using Induction and a SAT-Solver. FMCAD 2000: 108-125</p>
	   <p>[2] Alastair F. Donaldson, Leopold Haller, Daniel Kroening, Philipp Rümmer: Software Verification Using k-Induction. SAS 2011: 351-368</p>

	   <h3 id="multiple-files">Verification of modules that rely on larger structures</h3>

	   <p>ESBMC can verify code that relies on existing infrastructures and must be compliant with those. Consider the following C program where the verification engineer wants to check whether the assert-statement in line 8 holds.</p>

<pre class='brush: c'>
1 #include "lib.h"
2 // Running with esbmc  --overflow-check main.c lib.c
3 int main() {
4   int64_t a;
5   int64_t b;
6   int64_t r;
7   if (mul(a, b, &r)) {
8     __ESBMC_assert(r == a * b, "Expected result from multiplication");
9   }
10   return 0;
11 }
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

  The function <i>mul</i> is implemented in the library "lib.h", which is located under "/lib". Here, ESBMC is invoked as follows:

<pre style="color: silver; background: black;">$esbmc main.c --overflow-check -I lib/ lib/lib.c</pre>

<p>where <i>main.c</i> is the C program to be checked, <i>--overflow-check</i> enables arithmetic over- and underflow check, and <i>-I path</i> sets the include path. For this particular C program, ESBMC produces the following counterexample: </p>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file lib.c line 14 function mul thread 0
----------------------------------------------------
Violated property:
  file lib.c line 14 function mul
  arithmetic overflow on mul
  !overflow("*", a, b)

VERIFICATION FAILED
</pre>

<p>The library header and implementation files located under <i>/lib</i> are:</p>

          <pre class='brush: c'>
1 #include &lt;stdint.h>
2 _Bool mul(const int64_t a, const int64_t b, int64_t *res);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

          <pre class='brush: c'>
 1 #include "lib.h"
 2 _Bool mul(int64_t a, int64_t b, int64_t *res) {
 3   // Trivial cases
 4   if((a == 0) || (b == 0)) {
 5     *res = 0;
 6     return 1;
 7   } else if(a == 1) {
 8     *res = b;
 9     return 1;
10   } else if(b == 1) {
11     *res = a;
12     return 1;
13   }
14   *res = a * b; // there exists an overflow
15   return 1;
16 }
</pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

<h3 id="esbmc-python">Verification of Python Programs</h3>

<p> To enable the verification of Python programs, build ESBMC with the option:
</br><code>'-DENABLE_PYTHON_FRONTEND=On'</code>.</p>

<p>Users can specify the Python interpreter binary using a flag.</p>
<pre style="color: silver; background: black;">$esbmc --help</pre>
<pre class='brush: c'>
Python frontend:
--python path                         Python interpreter binary to use 
                                      (searched in $PATH; default: python)
</pre>

<pre style="color: silver; background: black;">$esbmc main.py --python python2.7</pre>
<pre class='brush: c'>
ESBMC version 7.6.1 64-bit x86_64 linux
Target: 64-bit little-endian x86_64-unknown-linux with esbmclibc
Parsing main.py
Python version: 2.7.18
ERROR: Please ensure Python 3 is available in your environment.
</pre>

<pre style="color: silver; background: black;">$esbmc main.py --python python3</pre>
<pre class='brush: c'>
ESBMC version 7.6.1 64-bit x86_64 linux
Target: 64-bit little-endian x86_64-unknown-linux with esbmclibc
Parsing main.py
Converting
Loading model: range.py
Loading model: int.py
Generating GOTO Program
GOTO program creation time: 0.151s
GOTO program processing time: 0.002s
Starting Bounded Model Checking
Symex completed in: 0.002s (14 assignments)
Slicing time: 0.000s (removed 10 assignments)
Generated 9 VCC(s), 2 remaining after simplification (4 assignments)
No solver specified; defaulting to Boolector
Encoding remaining VCC(s) using bit-vector/floating-point arithmetic
Encoding to solver time: 0.000s
Solving with solver Boolector 3.2.3
Runtime decision procedure: 0.000s
BMC program time: 0.003s

VERIFICATION SUCCESSFUL
</pre>
<p> Consider the following Python file, named main.py: </p>
<pre class='brush: c'>
def factorial(n:int) -> int:
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)

n:int = nondet_int()
__ESBMC_assume(n > 0);
__ESBMC_assume(n < 6);

result:int = factorial(n)
assert(result != 120)
</pre>

<p> Run ESBMC on the Python file using the following command:</p>
<pre><code>$ esbmc main.py --incremental-bmc </code></pre>

<p>ESBMC will analyze the program and detect the assertion violated when 'factorial' is invoked with the value 5. The counterexample generated by the tool will demonstrate this:</p>

<pre style="color: silver; background: black;">
  [Counterexample]


  State 1 file main.py line 7 column 0 thread 0
  ----------------------------------------------------
    n = 5 (00000000 00000000 00000000 00000101)

  State 4  thread 0
  ----------------------------------------------------
  Violated property:
    assertion
    result != 120


  VERIFICATION FAILED

  Bug found (k = 5)
  </pre>

<p>The <code>--function</code> flag can be used to verify a single function instead of the entire file:</p>
<pre><code>$ esbmc &lt;python-file&gt; --function &lt;function-name&gt;</code></pre>

<p>This command instructs ESBMC to focus only on the specified function, making the verification process more efficient when you are only interested in a particular part of the code.</p>


	   <h3 id="esbmc-solidity">Verification of Solidity Smart Contracts</h3>

     <p> ESBMC has a frontend to process Solidity source code and hence can verify simple Solidity smart contracts. In order to verify Solidity smart contract, ESBMC should be built with the option <b>'-DENABLE_SOLIDITY_FRONTEND=On'</b>.</p>
     <p> There are three relevant options, which are:</p>
     <ul>
      <li><b>sol:</b> sets the smart contract source file (<b>.sol</b> and <b>.solast</b>)</li>
      <li><b>contract:</b> sets the target contract name</li>
      <li><b>function:</b> sets the target function name</li>
     </ul>
     <p> As an illustrative example, consider the following Solidity code: </p>

<pre class='brush: c'>
1 // SPDX-License-Identifier: GPL-3.0
2 pragma solidity >=0.4.26;
3
4 contract MyContract {
5
6   function func_array_loop() external pure {
7     uint8[2] memory a;
8
9     a[0] = 100;
10    for (uint8 i = 1; i &lt; 3; ++i)
11    {
12      a[i] = 100;
13      assert(a[i-1] == 100);
14    }
15  }
16 }

</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
  SyntaxHighlighter.all()
</script>

  <p> As declared in line 7, <i>a</i> is an static array of the size 2. The loop in line 10 will try to write 10 in <i>a[2]</i> in the third iteration, which is out-of-bound access. This error can be detected by ESBMC using the command lines as follows: </p>

  <pre style="color: silver; background: black;">$esbmc --sol example.sol example.solast --contract MyContract --function func_array_loop --incremental-bmc </pre>

  <p> where <i>MyContract.solast</i> is the JSON AST of the Solidity source code generated using the command line below:</p>

  <pre style="color: silver; background: black;">$solc --ast-compact-json example.sol > example.solast</pre>

  <p> Since there is no ambiguous function name, the <b>--contract</b> option can be omitted. Note that the solidity compiler version should be greater or equal than 0.4.26. For this example, ESBMC produces the following counterexample:</p>
<pre style="color: silver; background: black;">
Counterexample:

State 1 file example.sol line 1 function func_array_loop thread 0
----------------------------------------------------
  a[0] = 100 (01100100)

State 2 file example.sol line 1 function func_array_loop thread 0
----------------------------------------------------
  a[1] = 100 (01100100)

State 4 file example.sol line 1 function func_array_loop thread 0
----------------------------------------------------
Violated property:
  file example.sol line 1 function func_array_loop
  array bounds violated: array `a' upper bound
  (signed long int)i &lt; 2


VERIFICATION FAILED

Bug found (k = 2)
</pre>

  <p>Like other state-of-art verifiers, ESBMC can also verify state properties. A common type of properties in smart contracts are properties that involve the state of the contract. Multiple transactions might be needed to make an assertion fail for such a property. Consider a a 2D grid: </p>

<pre class='brush: c'>
pragma solidity >=0.8.0;

contract Robot {
  int x = 0;
  int y = 0;

  function moveLeftUp() public {
      --x;
      ++y;
  }

  function moveLeftDown() public {
      --x;
      --y;
  }

  function moveRightUp() public {
      ++x;
      ++y;
  }

  function moveRightDown() public {
      ++x;
      --y;
  }

  function inv() public view {
      assert((x + y) % 2 != 0);
  }
}
</pre>

  <p> ESBMC prove that the assertion(Invariant) could be violated throughout the funtion calls, via command:</p>

  <pre style="color: silver; background: black;">$esbmc --sol example.sol example.solast --contract Robot --k-induction</pre>

  <p>The counterexample shows the path that leads to the assertion failure:</p>
<pre style="color: silver; background: black;">
[Counterexample]


State 1 file example.sol line 13 function moveLeftDown thread 0
----------------------------------------------------
  x = -2 (11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111110)

State 2 file example.sol line 14 function moveLeftDown thread 0
----------------------------------------------------
  y = 0 (00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000)

State 3 file example.sol line 18 function moveRightUp thread 0
----------------------------------------------------
  x = -1 (11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111)

State 4 file example.sol line 19 function moveRightUp thread 0
----------------------------------------------------
  y = 1 (00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001)

State 5 file example.sol line 23 function moveRightDown thread 0
----------------------------------------------------
  x = 0 (00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000)

State 6 file example.sol line 24 function moveRightDown thread 0
----------------------------------------------------
  y = 0 (00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000)

State 7 file example.sol line 28 function inv thread 0
----------------------------------------------------
Violated property:
  file example.sol line 28 function inv
  assertion
  (x + y) % 2 != 0


VERIFICATION FAILED
</pre>

           <p>We provide a technical report about the verification of Solidity programs <a href="https://arxiv.org/pdf/2111.13117.pdf">here</a>.</p>
	   <p>We also provide a Github action for security verification of solidity contracts using ESBMC-solidity <a href="https://github.com/actions-marketplace-validations/alanpjohn_esbmc-solidity-action" target=”_blank”>here</a>.</p>

     <h3 id="multiple-property-verification">Multiple Property Verification</h3>
     <pre style="color: silver; background: black;">$esbmc file.c --multi-property</pre>
     <p>
      ESBMC can verify the satisfiability of all the claims of a given bound. During this multi-property verification, ESBMC does not terminate when a counterexample is found; instead, it continues to run until all bugs have been discovered. There are three relevant options, which are:</p>
      <ul>
        <li><b>multi-property:</b> verifies the satisfiability of all claims of
          the current bound. This also activates <b>--no-remove-unreachable</b>.</li>
        <li><b>multi-fail-fast n:</b> stops after first <b>n</b> VCC violation found in multi-property mode</li>
        <li><b>keep-verified-claims:</b> do not skip verified claims in multi-property verification. With this option enabled, assertions inside the loop body will be verified repeatedly during the unwinding; while with this option disabled, the claims will only get verified once.</li>
      </ul>
     <p>An example of multi-property verification can be found in the <b>Code  Coverage Metric</b> section below.</p>

     <h3 id="code-coverage-metric">Code Coverage Metric</h3>
     <p>
      ESBMC provides a set of coverage metrics to help you measure how much of the state space you've visited. The supported coverage metrics can be listed as follows:</p>
      <ul>
        <li><b>Assertion Coverage</b> measures how well the Boolean expressions in the code have been tested</li>
        <li><b>Condition Coverage</b> measures how well the assertions within a program are tested</li>
      </ul>

     <p>
      As an illustrative example, consider the following C code:
     </p>
    <pre class='brush: c'>
1 int main()
2 {
3   int x = 0;
4   while (nondet_int())
5   {
6     if (!x)
7     {
8       assert(x == 0);
9       x = 1;
11     }
12     else if (x == 1)
13     {
14       assert(x > 0);
15       x = 2;
16     }
17     else if (x == 2)
18     {
19       assert(x >= 2);
20       x = 3;
21     }
22 }
23  assert(x == 3);
24  }
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
  SyntaxHighlighter.all()
</script>

<p>For assertion coverage, ESBMC is invoked as follows:</p>
<pre style="color: silver; background: black;">$esbmc example.c --k-induction --assertion-coverage</pre>

<p>For this particular C program, ESBMC produces the following counterexample and coverage information, reflecting that two branches in the program leave unexplored during verification:</p>
<pre style="color: silver; background: black;">
  [Counterexample]


  State 1 file example.c line 24 column 3 function main thread 0
  ----------------------------------------------------
  Violated property:
    file example.c line 24 column 3 function main
    x == 3
    0
  
  Slicing time: 0.000s (removed 0 assignments)
  No solver specified; defaulting to Boolector
  Solving claim 'x == 0' with solver Boolector 3.2.2
  Encoding remaining VCC(s) using bit-vector/floating-point arithmetic
  Encoding to solver time: 0.001s
  Solving with solver Boolector 3.2.2
  Runtime decision procedure: 0.000s
  
  [Counterexample]
  
  
  State 1 file example.c line 10 column 7 function main thread 0
  ----------------------------------------------------
  Violated property:
    file example.c line 10 column 7 function main
    x == 0
    0
  
  
  [Coverage]
  
  Total Asserts: 4
  Total Assertion Instances: 4
  Reached Assertion Instances: 2
  Assertion Instances Coverage: 50%
  
  VERIFICATION FAILED
  
  Bug found (k = 1)
</pre>

  <p>
    <ul>
      <li><b>Total Asserts:</b> the total number of assertions that are contained in the flow that ESBMC covers.</li>
      <li><b>Total Assertion Instances:</b> the number of times that assertion can be triggered after ESBMC folds the code. For example, if a loop with 4 iterations contains an assertion, this assertion has 4 instances</li>
      <li><b>Reached Assertion Instances:</b> the number of verified assertion instances. By using <b>--condition-coverage-claims</b>, the guard and location information of the instances are also listed</li>
      <li>The <b>coverage</b> is obtained by dividing reached assertion instances by total assertion instances.</li>
      <li>The <b>unreached claims</b> can be checked by comparing them with the output of <b>--show-claims</b>.</li>
    </ul>
  </p>
  <p>For condition coverage, ESBMC is invoked as follows:</p>
  <pre style="color: silver; background: black;">$esbmc example.c --k-induction --condition-coverage-claims</pre>
  <p>The output coverage result can be illustrated as follows:</p>
<pre style="color: silver; background: black;">
  [Coverage]

  !((_Bool)return_value$_nondet_int$1 != 0)     file example.c line 6 column 3 function main : SATISFIED
  (_Bool)return_value$_nondet_int$1 != 0        file example.c line 6 column 3 function main : SATISFIED
  !((_Bool)x != 0)      file example.c line 8 column 5 function main : SATISFIED
  (_Bool)x != 0 file example.c line 8 column 5 function main : SATISFIED
  !(x == 1)     file example.c line 13 column 10 function main : SATISFIED
  x == 1        file example.c line 13 column 10 function main : SATISFIED
  !(x == 2)     file example.c line 18 column 10 function main : SATISFIED
  x == 2        file example.c line 18 column 10 function main : SATISFIED
  !(x == 3)     file example.c line 24 column 3 function main : SATISFIED
  x == 3        file example.c line 24 column 3 function main : SATISFIED
  x == 0        file example.c line 10 column 7 function main : SATISFIED
  !(x == 0)     file example.c line 10 column 7 function main : UNSATISFIED
  x > 0 file example.c line 15 column 7 function main : SATISFIED
  !(x > 0)      file example.c line 15 column 7 function main : UNSATISFIED
  x >= 2        file example.c line 20 column 7 function main : SATISFIED
  !(x >= 2)     file example.c line 20 column 7 function main : UNSATISFIED
Reached Conditions:  16
Short Circuited Conditions:  0
Total Conditions:  16

Condition Properties - SATISFIED:  13
Condition Properties - UNSATISFIED:  3

Condition Coverage: 81.25%

VERIFICATION FAILED
</pre>
<p>
  <ul>
    <li><b>Total Conditions:</b> the total number of Boolean conditions</li>
    <li><b>Short Circuited Conditions:</b> the number of conditions that are short-circuited. This refers to the conditions in Boolean expressions that are not eventually evaluated as soon as the result is determined</li>
    <li><b>Reached Conditions:</b> the total number of conditions that are reached during the verification</li>
    <li><b>Condition Properties - SATISFIED/UNSATISFIED:</b> the number of conditions that are satisfied/unsatisfied</li>
    <li><b>Condition Coverage:</b> is obtained by dividing reached assertion instances by total assertion instances.</li>
  </ul>
</p>

<p>
  Note that the <b>--condition-coverage-claims</b> option provides verbose output of claim information, including its condition and location. If only the coverage number is needed, we recommend using the <b>--condition-coverage</b> option instead.
</p>
 
      <h3 id="smt-backends">Supported SMT backends</h3>
      <p>ESBMC integrates a number of SMT solvers directly via their respective
         API, but on Unix can also be instructed to communicate with an external
         SMT solver process by a pipe. The following table lists ESBMC's options
         enabling the use of the particular solver.</p>

      <table>
        <thead>
          <tr><td>Backend</td><td>Option</td></tr>
        </thead>
        <tr><td>Boolector</td><td><code>--boolector</code> (this is the default)</td></tr>
        <tr><td>Z3</td><td><code>--z3</code></td></tr>
        <tr><td>MathSAT</td><td><code>--mathsat</code></td></tr>
        <tr><td>CVC4</td><td><code>--cvc</code></td></tr>
        <tr><td>Yices</td><td><code>--yices</code></td></tr>
        <tr><td>Bitwuzla</td><td><code>--bitwuzla</code></td></tr>
        <tr><td>SMTLIB</td><td><code>--smtlib --smtlib-solver-prog CMD</code>
          (see below for details about the placeholder <code>CMD</code>)</td></tr>
      </table>

      <p>While Boolector is the default, an alternative default solver can also
         be specified with the <code>--default-solver SOLVER</code> option, where
         <code>SOLVER</code> corresponds to one of the above options without the
         <code>--</code>. This option is particular suited for a shell alias or the
         <code>ESBMC_OPTS</code> environment variable, which is parsed every time
         ESBMC runs.</p>

      <p>The <code>CMD</code> parameter for the SMTLIB backend is a string that is
         interpreted by the shell, therefore it can contain additional options
         to a particular command separated by whitespace, or even chain together
         multiple commands. Here are some examples for CMD that work with ESBMC.
         Note that the tools in these commands are assumed to be available
         through the <code>PATH</code> environment variable:</p>
      <ul>
        <li><code>boolector --incremental</code></li>
        <li><code>z3 -in</code></li>
        <li><code>tee formula.smt2 | z3 -in | tee output.txt</code></li>
        <li><code>yices-smt2 --incremental</code></li>
        <li><code>cvc5 -L smt2 -m</code></li>
      </ul>

      <p>Remember to quote the <code>CMD</code> string when executing ESBMC.</p>

	   <h3 id="esbmc-support">ESBMC Support</h3>

          <p>We are still increasing the robustness of ESBMC and also continuously implementing new features, more optimizations and experiencing new encodings. For any question about ESBMC, please contact us via <code>https://github.com/esbmc/esbmc</code>.</p>

        </section>
      <footer>

        <p><small>© 2020 Systems & Software Verification Laboratory</small></p>
      </footer>
    </div>
    <script src="./files/scale.fix.js.download"></script>

</body></html>
